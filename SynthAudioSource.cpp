#include "SynthAudioSource.h"


struct SineWaveSound : public SynthesiserSound {
  SineWaveSound() {}
  bool appliesToNote (int /*midiNoteNumber*/) override    { return true; }
  bool appliesToChannel (int /*midiChannel*/) override    { return true; }
};

SineWaveVoice::SineWaveVoice() {}

bool SineWaveVoice::canPlaySound (SynthesiserSound* sound) override {
  return dynamic_cast<SineWaveSound*> (sound) != nullptr;
}

void SineWaveVoice::startNote (int midiNoteNumber, float velocity,
                               SynthesiserSound*, int /*currentPitchWheelPosition*/) override {
  currentAngle = 0.0;
  level = velocity * 0.15;
  tailOff = 0.0;
  
  auto cyclesPerSecond = MidiMessage::getMidiNoteInHertz (midiNoteNumber);
  auto cyclesPerSample = cyclesPerSecond / getSampleRate();
  
  angleDelta = cyclesPerSample * MathConstants<double>::twoPi;
}

void SineWaveVoice::stopNote (float /*velocity*/, bool allowTailOff) override {
  if (allowTailOff) {
    // start a tail-off by setting this flag. The render callback will pick up on
    // this and do a fade out, calling clearCurrentNote() when it's finished.
    
    if (tailOff == 0.0) // we only need to begin a tail-off if it's not already doing so - the
      tailOff = 1.0;  // stopNote method could be called more than once.
  }
  else
    {
      // we're being told to stop playing immediately, so reset everything..
      clearCurrentNote();
      angleDelta = 0.0;
    }
}

void SineWaveVoice::pitchWheelMoved (int /*newValue*/) override                              {}
void SineWaveVoice::controllerMoved (int /*controllerNumber*/, int /*newValue*/) override    {}

void SineWaveVoice::renderNextBlock (AudioBuffer<float>& outputBuffer, int startSample, int numSamples) override {
  if (angleDelta != 0.0) {
    if (tailOff > 0.0) {
      while (--numSamples >= 0) {
        auto currentSample = (float) (std::sin (currentAngle) * level * tailOff);
        
        for (auto i = outputBuffer.getNumChannels(); --i >= 0;)
          outputBuffer.addSample (i, startSample, currentSample);
        
        currentAngle += angleDelta;
        ++startSample;
        
        tailOff *= 0.99;
        
        if (tailOff <= 0.005) {
            clearCurrentNote();
            
            angleDelta = 0.0;
            break;
          }
      }
    }
    else {
      while (--numSamples >= 0) {
        auto currentSample = (float) (std::sin (currentAngle) * level);
        
        for (auto i = outputBuffer.getNumChannels(); --i >= 0;)
          outputBuffer.addSample (i, startSample, currentSample);
        
        currentAngle += angleDelta;
        ++startSample;
      }
    }
  }
}


SynthAudioSource::SynthAudioSource (MidiKeyboardState& keyState)  : keyboardState (keyState) {
  // Add some voices to our synth, to play the sounds..
  for (auto i = 0; i < 4; ++i) {
    synth.addVoice (new SineWaveVoice());   // These voices will play our custom sine-wave sounds..
    synth.addVoice (new SamplerVoice());    // and these ones play the sampled sounds
  }
  
  setUsingSineWaveSound();
}

void SynthAudioSource::setUsingSineWaveSound() {
  synth.clearSounds();
  synth.addSound (new SineWaveSound());
}

void SynthAudioSource::setUsingSampledSound() {
  WavAudioFormat wavFormat;
  
  std::unique_ptr<AudioFormatReader> audioReader (wavFormat.createReaderFor (createAssetInputStream ("cello.wav").release(), true));
  
  BigInteger allNotes;
  allNotes.setRange (0, 128, true);
  
  synth.clearSounds();
  synth.addSound (new SamplerSound ("demo sound",
                                    *audioReader,
                                    allNotes,
                                    74,   // root midi note
                                    0.1,  // attack time
                                    0.1,  // release time
                                    10.0  // maximum sample length
                                    ));
}

void SynthAudioSource::prepareToPlay (int /*samplesPerBlockExpected*/, double sampleRate) override {
  midiCollector.reset (sampleRate);  
  synth.setCurrentPlaybackSampleRate (sampleRate);
}

void SynthAudioSource::releaseResources() override {}

void SynthAudioSource::getNextAudioBlock (const AudioSourceChannelInfo& bufferToFill) override {
  // the synth always adds its output to the audio buffer, so we have to clear it
  // first..
  bufferToFill.clearActiveBufferRegion();
  
  // fill a midi buffer with incoming messages from the midi input.
  MidiBuffer incomingMidi;
  midiCollector.removeNextBlockOfMessages (incomingMidi, bufferToFill.numSamples);
  
  // pass these messages to the keyboard state so that it can update the component
  // to show on-screen which keys are being pressed on the physical midi keyboard.
  // This call will also add midi messages to the buffer which were generated by
  // the mouse-clicking on the on-screen keyboard.
  keyboardState.processNextMidiBuffer (incomingMidi, 0, bufferToFill.numSamples, true);
  
  // and now get the synth to process the midi events and generate its output.
  synth.renderNextBlock (*bufferToFill.buffer, incomingMidi, 0, bufferToFill.numSamples);
}


AudioSynthesiserDemo::AudioSynthesiserDemo() {
  addAndMakeVisible (keyboardComponent);
  
  addAndMakeVisible (sineButton);
  sineButton.setRadioGroupId (321);
  sineButton.setToggleState (true, dontSendNotification);
  sineButton.onClick = [this] { synthAudioSource.setUsingSineWaveSound(); };
  
  addAndMakeVisible (sampledButton);
  sampledButton.setRadioGroupId (321);
  sampledButton.onClick = [this] { synthAudioSource.setUsingSampledSound(); };
  
  addAndMakeVisible (liveAudioDisplayComp);
  audioDeviceManager.addAudioCallback (&liveAudioDisplayComp);
  audioSourcePlayer.setSource (&synthAudioSource);
  
#ifndef JUCE_DEMO_RUNNER
  RuntimePermissions::request (RuntimePermissions::recordAudio,
                               [this] (bool granted)
                               {
                                 int numInputChannels = granted ? 2 : 0;
                                 audioDeviceManager.initialise (numInputChannels, 2, nullptr, true, {}, nullptr);
                               });
#endif
  
  audioDeviceManager.addAudioCallback (&audioSourcePlayer);
  audioDeviceManager.addMidiInputDeviceCallback ({}, &(synthAudioSource.midiCollector));
  
  setOpaque (true);
  setSize (640, 480);
}

AudioSynthesiserDemo::~AudioSynthesiserDemo() override {
  audioSourcePlayer.setSource (nullptr);
  audioDeviceManager.removeMidiInputDeviceCallback ({}, &(synthAudioSource.midiCollector));
  audioDeviceManager.removeAudioCallback (&audioSourcePlayer);
  audioDeviceManager.removeAudioCallback (&liveAudioDisplayComp);
}

//==============================================================================
void AudioSynthesiserDemo::paint (Graphics& g) override {
  g.fillAll (getUIColourIfAvailable (LookAndFeel_V4::ColourScheme::UIColour::windowBackground));
}

void AudioSynthesiserDemo::resized() override {
  keyboardComponent   .setBounds (8, 96, getWidth() - 16, 64);
  sineButton          .setBounds (16, 176, 150, 24);
  sampledButton       .setBounds (16, 200, 150, 24);
  liveAudioDisplayComp.setBounds (8, 8, getWidth() - 16, 64);
}
